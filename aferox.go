package aferox

import (
	"path/filepath"
	"strings"

	"github.com/spf13/afero"
)

// Aferox adjusts all relative paths based on the stored
// working directory, instead of relying on the default behavior for relative
// paths defined by the implementing Fs.
type Aferox struct {
	*afero.Afero

	// Fs is the working directory aware filesystem.
	Fs *Fsx
}

// NewAferox creates a wrapper around a filesystem representation with
// an independent working directory.
func NewAferox(dir string, fs afero.Fs) Aferox {
	wrapper := NewFsx(dir, fs)
	return Aferox{
		Afero: &afero.Afero{Fs: wrapper},
		Fs:    wrapper,
	}
}

// Getwd returns a rooted path name corresponding to the current directory.
// Use in place of os.Getwd.
func (a Aferox) Getwd() string {
	return a.Fs.Getwd()
}

// Chdir changes the current working directory to the named directory.
// Use in place of os.Chdir.
func (a Aferox) Chdir(dir string) {
	a.Fs.Chdir(dir)
}

// Abs returns an absolute representation of path. If the path is not absolute
// it will be joined with the current working directory to turn it into an
// absolute path. The absolute path name for a given file is not guaranteed to
// be unique. Abs calls Clean on the result.
// Use in place of filepath.Abs.
func (a Aferox) Abs(path string) string {
	return a.Fs.Abs(path)
}

// This is a simplified exec.LookPath that checks if command is accessible given
// a PATH string.
// Use in place of exec.LookPath when you need need an independent check that a file
// exists in a path list, for example you do not want to use the current process's
// environment variables.
func (a Aferox) LookPath(cmd string, path string, pathExt string) (string, bool) {
	// Use a list of common filepath extensions only when an extension isn't present
	exts := []string{""}
	if filepath.Ext(cmd) == "" {
		exts = strings.Split(strings.ToLower(pathExt), ";")
	}

	paths := filepath.SplitList(path)
	for _, p := range paths {
		files, err := a.ReadDir(p)
		if err != nil {
			continue
		}

		for _, f := range files {
			if f.IsDir() {
				continue
			}

			gotFileName := f.Name()

			// Check for a matching file using each possible file extension
			for _, ext := range exts {
				wantFileName := cmd + ext

				// Use a case insensitive check to determine if we have a match.
				// This won't work where two files have the same name, e.g. MyFile and myfile
				if strings.EqualFold(wantFileName, gotFileName) {
					return filepath.Join(p, gotFileName), true
				}
			}
		}
	}

	return "", false
}

// TempDir creates a new temporary directory in the directory dir
// with a name beginning with prefix and returns the path of the
// new directory.  If dir is the empty string, TempDir uses the
// default directory for temporary files (see os.TempDir).
// Multiple programs calling TempDir simultaneously
// will not choose the same directory.  It is the caller's responsibility
// to remove the directory when no longer needed.
func (a Aferox) TempDir(dir string, prefix string) (string, error) {
	if dir != "" {
		dir = a.Abs(dir)
	}
	return a.Afero.TempDir(dir, prefix)
}

// TempFile creates a new temporary file in the directory dir,
// opens the file for reading and writing, and returns the resulting *os.File.
// The filename is generated by taking pattern and adding a random
// string to the end. If pattern includes a "*", the random string
// replaces the last "*".
// If dir is the empty string, TempFile uses the default directory
// for temporary files (see os.TempDir).
// Multiple programs calling TempFile simultaneously
// will not choose the same file. The caller can use f.Name()
// to find the pathname of the file. It is the caller's responsibility
// to remove the file when no longer needed.
func (a Aferox) TempFile(dir string, pattern string) (afero.File, error) {
	if dir != "" {
		dir = a.Abs(dir)
	}
	return a.Afero.TempFile(dir, pattern)
}
